# Quickstart

RV-Match currently consists of only one tool, `kcc`, which is designed as a drop-off replacement for the `gcc` C compiler. After installation (see [Installing](./installing.md) for help), simply open a terminal (on Windows 10, open the Ubuntu bash of Windows Subsystem for Linux) and then use `kcc` to compile programs the same way you use `gcc`, for example:

```bash
kcc file.c
./a.out
```

Since `kcc` is implemented in Java, the first time you invoke it may take significantly longer than subsequent invocations, due to JVM warmup costs. So please be patient the first time you invoke `kcc`, as it may even take 30 seconds or longer, depending on your machine, no matter how small your program is. The second invocation of `kcc` will be much faster (about one order of magnitude faster).

`kcc --help` will provide usage information, but in general, options should be roughly the same as `gcc`â€˜s. There are a few options specific to `kcc`, though, including the following:

* The `-profile` option allows you to switch to a profile of your choice. A profile is referred to by a unique name, and consists of an instance of C11 to a particular architecture, operating system, compiler and library implementation. To see the current profile as well as all the available profiles that you can choose from, type `kcc -v`.
* The `-fissue-report=<file>` option tells `kcc` to write its issues to `<file>` instead of the standard output. The format for the file (CSV/JSON) is inferred from the specified file extension. If `<file>` is given with a relative path, then `kcc` generates the report (containing compilation issues) relative to the working directory of `kcc`, and the generated executable, if any, will generate a report (containing runtime issues) relative to the working directory the executable is run from. So the two reports will be in the same file given with a relative path only if you run both `kcc` and the generated executable from the same directory. You can also pass `<file>` with an absolute path, in which case all error reports are put in the same file: this is especially useful when using `kcc` with a large multi-directory project. You can also set the RV\_ISSUE\_REPORT environment variable, which will provide the same functionality. In cases of conflict, the value of the environment variable overrides the value of the compiler flag.
* The `-Wlint` (or `-flint`) option tells `kcc` to report not only errors, but also warnings. The difference between errors and warnings is that the former violate the ISO C11 standard, so they must be fixed in order for your program to be standards-compliant, while the latter may be indicative of potential defects even though they can also occur in strictly-conforming C11 programs. One such warning is the dynamic memory overflow; use the flag `-fheap-size` to assign a maximum memory size (beyond which heap-allocation functions like malloc will report a warning and return a null pointer). See [*Running Examples*](./runningexamples.md) for details and examples.
* The `-frecover-all-errors` option tells `kcc` that we wish to recover from errors that would otherwise be considered fatal errors. This includes undefined behavior that can crash the program, such as a null pointer dereferencing, as well as certain constraint violations that would normally be considered cause for a standards-compliant compiler (e.g. `gcc -pedantic-errors`) to reject the program. Note that this option has an adverse effect on the return code of `kcc`, causing it to return status code 0 on the command line even in cases that would otherwise be considered fatal compiler errors for `kcc`. As such, it is strongly recommended that this option not be passed to a configure script but instead be placed directly in the Makefile after configure has run, otherwise, the project you are compiling might not compile correctly.
